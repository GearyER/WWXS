{"version":3,"file":"load_sources.js","sourceRoot":"","sources":["../../src/api/load_sources.ts"],"names":[],"mappings":";;;AAOA,mCAAsC;AACtC,iDAAgD;AAChD,qCAAiC;AACjC,+CAAgD;AAChD,uCAAuD;AAEvD;;;;;;GAMG;AACI,KAAK,UAAU,WAAW,CAC/B,WAAgC,EAChC,cAA+B,EAAE;IAEjC,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,GAAG,IAAA,8BAAgB,EAAC,WAAW,CAAC,CAAA;IACrD,MAAM,MAAM,GAAG,IAAI,iBAAO,CAAC,MAAM,CAAC,CAAA;IAClC,MAAM,KAAK,GAAG,sBAAW,CAAC,IAAI,EAAE,CAAA;IAChC,MAAM,EAAE,sBAAsB,EAAE,YAAY,EAAE,GAAG,MAAM,IAAA,oBAAY,EACjE,GAAG,EACH,WAAW,CACZ,CAAA;IACD,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;QAC7B,OAAO;YACL,IAAI,EAAE,EAAE;YACR,MAAM,EAAE,EAAE;SACX,CAAA;KACF;IACD,MAAM,EAAE,eAAe,EAAE,WAAW,EAAE,GAAG,MAAM,IAAA,qCAA2B,EAAC;QACzE,KAAK;QACL,GAAG;QACH,MAAM;QACN,sBAAsB;QACtB,YAAY;QACZ,WAAW;KACZ,CAAC,CAAA;IACF,MAAM,IAAI,GAAqB,eAAe,CAAC,GAAG,CAChD,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,EAAE,EAAE,CAAC,CAAC;QACzB,IAAI,EAAE,MAAM,CAAC,IAAI;QACjB,GAAG,EAAE,MAAM,CAAC,GAAG;QACf,QAAQ;KACT,CAAC,CACH,CAAA;IACD,MAAM,MAAM,GAAoB,WAAW,CAAC,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,EAAE,EAAE;QACtE,OAAO;YACL,GAAG,EAAE,MAAM,CAAC,GAAG;YACf,QAAQ,EAAE,MAAM,CAAC,QAAQ;YACzB,OAAO;SACR,CAAA;IACH,CAAC,CAAC,CAAA;IACF,OAAO;QACL,IAAI;QACJ,MAAM;KACP,CAAA;AACH,CAAC;AA3CD,kCA2CC","sourcesContent":["import {\n  ILoadSourcesResult,\n  IPlannedPickle,\n  IRunEnvironment,\n  ISourcesCoordinates,\n  ISourcesError,\n} from './types'\nimport { resolvePaths } from './paths'\nimport { IdGenerator } from '@cucumber/messages'\nimport { Console } from 'console'\nimport { mergeEnvironment } from './environment'\nimport { getFilteredPicklesAndErrors } from './gherkin'\n\n/**\n * Load and parse features, produce a filtered and ordered test plan and/or parse errors.\n *\n * @public\n * @param coordinates - Coordinates required to find features\n * @param environment - Project environment.\n */\nexport async function loadSources(\n  coordinates: ISourcesCoordinates,\n  environment: IRunEnvironment = {}\n): Promise<ILoadSourcesResult> {\n  const { cwd, stderr } = mergeEnvironment(environment)\n  const logger = new Console(stderr)\n  const newId = IdGenerator.uuid()\n  const { unexpandedFeaturePaths, featurePaths } = await resolvePaths(\n    cwd,\n    coordinates\n  )\n  if (featurePaths.length === 0) {\n    return {\n      plan: [],\n      errors: [],\n    }\n  }\n  const { filteredPickles, parseErrors } = await getFilteredPicklesAndErrors({\n    newId,\n    cwd,\n    logger,\n    unexpandedFeaturePaths,\n    featurePaths,\n    coordinates,\n  })\n  const plan: IPlannedPickle[] = filteredPickles.map(\n    ({ location, pickle }) => ({\n      name: pickle.name,\n      uri: pickle.uri,\n      location,\n    })\n  )\n  const errors: ISourcesError[] = parseErrors.map(({ source, message }) => {\n    return {\n      uri: source.uri,\n      location: source.location,\n      message,\n    }\n  })\n  return {\n    plan,\n    errors,\n  }\n}\n"]}