#!/usr/bin/env node

/* require('dotenv').config(); */

/**
 * Module dependencies.
 */

const debug = require('debug')('api:server');
const http = require('http');
const {
  app, sequelize, models, databaseConfig
} = require('../app');

const testData = require('../testdata'); // Test data for seeding database

/**
 * Get port from environment and store in Express.
 */

const port = normalizePort(process.env.PORT);
app.set('port', port);

/**
 * Create HTTP server.
 */

const server = http.createServer(app);

/**
 * Sync database.
 * Listen on provided port, on all network interfaces.
 */

sequelize.sync(databaseConfig).then(async () => { // TODO: Use sequelize.migration() instead
  // if (databaseConfig.force) {
  //   await seedDatabase(testData);
  // }
  server.listen(port);
  server.on('error', onError);
  server.on('listening', onListening);
});

// get data from app
app.post('/data', (req, res) => {
  const dataArray = req.body; // Access the array of arrays from the request body
  console.log('Received data from mobile app:', dataArray);

  // Process the data and send a response back to the mobile app
  seedDatabase(dataArray)
    .then(() => res.send('Data received and processed successfully'))
    .catch((err) => {
      console.error(err);
      res.status(500).send('Error processing data');
    });
});

/**
 * Seed database.
 * Go through sent data and create a new entry
*/

// parse each entry in sent data
const parseData = (data, length, fields) => {
  const result = [];
  for (let i = 0; i < data.length; i += length) {
    const obj = {};
    fields.forEach((field, index) => {
      obj[field] = data[i + index];
    });
    result.push(obj);
  }
  return result;
};

// put each entry into the database  // NOTE this must be sent in order
// TODO generalize this to get any sent data
const seedDatabase = async (data) => {
  const groups = parseData(data[0], 1, ['name']);
  const locations = parseData(data[1], 3, ['name', 'latitude', 'longitude']);
  const users = parseData(data[2], 4, ['username', 'password', 'role', 'groupId']);
  const buoys = parseData(data[3], 4, ['name', 'mac', 'groupId', 'locationId']);
  const ddata = parseData(data[4], 7, ['timestamp', 'surfTemp', 'surfInsolation', 'shallowSalinity', 'shallowTemp', 'depthTemp', 'depthTurbidity']);
  const history = parseData(data[5], 4, ['start', 'end', 'buoyId', 'locationId']);

  await createGroups(groups);
  await createLocations(locations);
  await createUsers(users);
  await createBuoys(buoys);
  await createData(ddata);
  await createHistory(history);
};

// create models from data
const createBulk = (model, items) => new Promise((resolve, reject) => {
  model.bulkCreate(items)
    .then(() => {
      resolve();
    })
    .catch((err) => {
      console.error(err);
      reject(err);
    });
});

const createGroups = (groups) => createBulk(models.Group, groups);
const createLocations = (locations) => createBulk(models.Location, locations);
const createUsers = (users) => createBulk(models.User, users);
const createBuoys = (buoys) => createBulk(models.Buoy, buoys);
const createData = (data) => createBulk(models.Data, data);
const createHistory = (history) => createBulk(models.History, history);


/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  const portNumber = parseInt(val, 10);

  if (isNaN(portNumber)) {
    // named pipe
    return val;
  }

  if (portNumber >= 0) {
    // port number
    return portNumber;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  const bind = typeof port === 'string'
    ? `Pipe ${port}`
    : `Port ${port}`;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(`${bind} requires elevated privileges`);
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(`${bind} is already in use`);
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  const addr = server.address();
  const bind = typeof addr === 'string'
    ? `pipe ${addr}`
    : `port ${addr.port}`;
  debug(`Listening on ${bind}`);
}
